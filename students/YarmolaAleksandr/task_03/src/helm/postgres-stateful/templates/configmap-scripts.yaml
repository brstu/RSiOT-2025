# yamllint disable rule:document-start rule:syntax rule:line-length
{{- if .Values.scripts.enabled}}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{.Values.scripts.name}}
  namespace: {{.Values.namespace.name}}
  labels:
    app: {{.Values.labels.app}}
    component: scripts
    org.bstu.course: {{.Values.labels.course | quote}}
    org.bstu.student.id: {{.Values.student.id | quote}}
    org.bstu.variant: {{.Values.student.variant | quote}}
data:
  backup.sh: |
    #!/bin/bash
    set -e

    echo "=== PostgreSQL Backup Script ==="
    echo "Student ID: ${STU_ID:-{{.Values.student.id}}}"
    echo "Group: ${STU_GROUP:-{{.Values.student.group}}}"
    echo "Variant: ${STU_VARIANT:-{{.Values.student.variant}}}"
    echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"

    # Параметры подключения
    DB_HOST="${POSTGRES_HOST:-{{.Values.service.name}}}"
    DB_PORT="${POSTGRES_PORT:-{{.Values.postgres.port}}}"
    DB_USER="${POSTGRES_USER:-{{.Values.postgres.credentials.username}}}"
    DB_NAME="${POSTGRES_DB:-{{.Values.postgres.credentials.database}}}"

    # Путь для backup
    BACKUP_DIR="/backups"
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="${BACKUP_DIR}/backup_${TIMESTAMP}.sql.gz"

    echo "Connecting to PostgreSQL at ${DB_HOST}:${DB_PORT}..."
    echo "Database: ${DB_NAME}"

    # Проверка доступности базы
    until PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d "${DB_NAME}" -c '\q'; do
      echo "Waiting for PostgreSQL to be ready..."
      sleep 2
    done

    echo "PostgreSQL is ready. Starting backup..."

    # Создание backup
    PGPASSWORD="${POSTGRES_PASSWORD}" pg_dump \
      -h "${DB_HOST}" \
      -U "${DB_USER}" \
      -d "${DB_NAME}" \
      --no-owner \
      --no-acl \
      | gzip > "${BACKUP_FILE}"

    if [ -f "${BACKUP_FILE}" ]; then
      BACKUP_SIZE=$(du -h "${BACKUP_FILE}" | cut -f1)
      echo "✅ Backup completed successfully!"
      echo "File: ${BACKUP_FILE}"
      echo "Size: ${BACKUP_SIZE}"
      
      # Удаление старых backup (оставляем последние {{.Values.backup.retention}})
      echo "Cleaning old backups (keeping last {{.Values.backup.retention}})..."
      ls -t ${BACKUP_DIR}/backup_*.sql.gz | tail -n +{{add1 .Values.backup.retention}} | xargs -r rm -f
      
      # Список всех backup
      echo "Available backups:"
      ls -lh ${BACKUP_DIR}/backup_*.sql.gz 2>/dev/null || echo "No backups found"
    else
      echo "❌ Backup failed!"
      exit 1
    fi

    echo "=== Backup Complete ==="

  restore.sh: |
    #!/bin/bash
    set -e

    echo "=== PostgreSQL Restore Script ==="
    echo "Student ID: ${STU_ID:-{{.Values.student.id}}}"
    echo "Group: ${STU_GROUP:-{{.Values.student.group}}}"
    echo "Variant: ${STU_VARIANT:-{{.Values.student.variant}}}"
    echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"

    # Параметры подключения
    DB_HOST="${POSTGRES_HOST:-{{.Values.service.name}}}"
    DB_PORT="${POSTGRES_PORT:-{{.Values.postgres.port}}}"
    DB_USER="${POSTGRES_USER:-{{.Values.postgres.credentials.username}}}"
    DB_NAME="${POSTGRES_DB:-{{.Values.postgres.credentials.database}}}"

    BACKUP_DIR="/backups"
    LATEST_BACKUP=$(ls -t ${BACKUP_DIR}/backup_*.sql.gz 2>/dev/null | head -n1)

    if [ -z "$LATEST_BACKUP" ]; then
        echo "❌ No backup found in ${BACKUP_DIR}"
        exit 1
    fi

    echo "Restoring from: ${LATEST_BACKUP}"

    # Проверка доступности базы
    until PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d postgres -c '\q'; do
      echo "Waiting for PostgreSQL to be ready..."
      sleep 2
    done

    # Завершить все активные подключения
    PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d postgres -c \
      "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='${DB_NAME}' AND pid <> pg_backend_pid();" || true

    # Удалить и создать базу заново
    PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d postgres -c \
      "DROP DATABASE IF EXISTS ${DB_NAME};"
    PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d postgres -c \
      "CREATE DATABASE ${DB_NAME};"

    # Восстановить из backup
    gunzip -c ${LATEST_BACKUP} | PGPASSWORD="${POSTGRES_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d "${DB_NAME}"

    echo "✅ Restore completed successfully!"
    echo "Database ${DB_NAME} restored from ${LATEST_BACKUP}"
{{- end}}
