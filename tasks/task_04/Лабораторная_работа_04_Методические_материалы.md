# ЛР04 — Наблюдаемость, Helm и GitOps

План

- Обзор: метрики/логи/трейсы (OpenTelemetry), Prometheus + Grafana, Alertmanager.
- Практика: установка мониторинга, экспонирование метрик приложения, дашборды и алерты.
- Helm‑чарт приложения и (по возможности) GitOps с Argo CD/Flux.
- Варианты (45) по SLO/порогам и префиксам метрик.
- Материалы и раздел «отладка».

## Необходимые знания и ПО

- Кластер Kubernetes (minikube/kind или managed-кластер), установлен `kubectl`.
- Helm 3 для управления чартами и релизами.
- Базовые знания PromQL (язык запросов Prometheus) для создания запросов и алертов.
- Понимание концепций метрик: counters, gauges, histograms, summaries.

## Краткая теория

- Observability (наблюдаемость) = логирование, метрики, трассировка. На старте достаточно метрик и алертов по SLO для понимания состояния системы.
- kube‑prometheus‑stack — готовое решение, разворачивающее Prometheus (сбор метрик), Alertmanager (управление алертами), Grafana (визуализация) и экспортеры метрик для Kubernetes компонентов. Приложению нужен HTTP endpoint `/metrics` в формате Prometheus.
- Helm параметризует манифесты через templates и values, упрощает управление релизами и версионирование конфигурации.
- GitOps фиксирует желаемое состояние инфраструктуры в Git и автоматически синхронизирует кластер (Argo CD/Flux), обеспечивая декларативность и аудит изменений.

## Практика

1. Установка системы мониторинга

   - Добавьте Helm-репозиторий: `helm repo add prometheus-community https://prometheus-community.github.io/helm-charts && helm repo update`
   - Установите kube‑prometheus‑stack в namespace `monitoring`:
     ```bash
     helm install monitoring prometheus-community/kube-prometheus-stack \
       -n monitoring --create-namespace
     ```
   - Проверьте развёрнутые компоненты: `kubectl get pods -n monitoring`
   - Получите доступ к Grafana: `kubectl port-forward svc/monitoring-grafana 3000:80 -n monitoring`
   - Логин по умолчанию: `admin` / `prom-operator` (можно изменить через values)

2. Создайте namespace и базовые манифесты приложения

   - `namespace.yaml`

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: app-monitoring
```

3. Интеграция метрик в приложение

   - Добавьте client-библиотеку Prometheus в ваше приложение (ЛР01):
     - Go: `github.com/prometheus/client_golang/prometheus`
     - Python: `prometheus-client`
     - Node.js: `prom-client`
     - Java: `io.prometheus:simpleclient`
   - Создайте endpoint `/metrics` с префиксом согласно варианту (например, `app01_`)
   - Экспонируйте базовые метрики:
     - Counter: `<prefix>http_requests_total{method, status}`
     - Histogram: `<prefix>http_request_duration_seconds{method}`
     - Gauge: `<prefix>active_connections`

   Пример для Go:
   ```go
   import (
       "github.com/prometheus/client_golang/prometheus"
       "github.com/prometheus/client_golang/prometheus/promhttp"
   )

   var (
       httpRequestsTotal = prometheus.NewCounterVec(
           prometheus.CounterOpts{
               Name: "app01_http_requests_total",
               Help: "Total number of HTTP requests",
           },
           []string{"method", "status"},
       )
       httpRequestDuration = prometheus.NewHistogramVec(
           prometheus.HistogramOpts{
               Name:    "app01_http_request_duration_seconds",
               Help:    "HTTP request latency",
               Buckets: prometheus.DefBuckets,
           },
           []string{"method"},
       )
   )

   func init() {
       prometheus.MustRegister(httpRequestsTotal)
       prometheus.MustRegister(httpRequestDuration)
   }

   // В HTTP handler
   http.Handle("/metrics", promhttp.Handler())
   ```

4. Создайте ServiceMonitor для автоматического сбора метрик

   - `servicemonitor.yaml`

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: app-monitor
  namespace: app-monitoring
  labels:
    release: monitoring  # Важно для discovery
spec:
  selector:
    matchLabels:
      app: web-app
  endpoints:
    - port: http
      path: /metrics
      interval: 30s
```

5. Создайте дашборды и алерты

   - Дашборды в Grafana:
     - Availability: `sum(rate(<prefix>http_requests_total{status!~"5.."}[5m])) / sum(rate(<prefix>http_requests_total[5m])) * 100`
     - P95 Latency: `histogram_quantile(0.95, rate(<prefix>http_request_duration_seconds_bucket[5m]))`
     - Error Rate: `sum(rate(<prefix>http_requests_total{status=~"5.."}[5m])) / sum(rate(<prefix>http_requests_total[5m])) * 100`

   - PrometheusRule для алертов: `prometheusrule.yaml`

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: app-alerts
  namespace: app-monitoring
  labels:
    release: monitoring
spec:
  groups:
    - name: slo-alerts
      interval: 30s
      rules:
        - alert: HighErrorRate
          expr: |
            sum(rate(app01_http_requests_total{status=~"5.."}[10m])) 
            / sum(rate(app01_http_requests_total[10m])) > 0.02
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "High 5xx error rate detected"
            description: "Error rate is {{ $value | humanizePercentage }}"
        - alert: HighLatency
          expr: |
            histogram_quantile(0.95, 
              rate(app01_http_request_duration_seconds_bucket[5m])
            ) > 0.300
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "P95 latency exceeded SLO"
            description: "P95 latency is {{ $value }}s"
```

6. Упакуйте приложение в Helm-чарт

   - Структура чарта:
     ```
     helm/
       my-app/
         Chart.yaml
         values.yaml
         templates/
           deployment.yaml
           service.yaml
           ingress.yaml
           servicemonitor.yaml
           prometheusrule.yaml
     ```

   - `values.yaml` с параметризацией:
     ```yaml
     namespace: app-monitoring
     replicaCount: 2
     image:
       repository: myapp
       tag: latest
     metrics:
       prefix: app01_
       enabled: true
     slo:
       availability: 99.0
       p95Latency: 300ms
       errorRate: 2%
     resources:
       requests:
         cpu: 100m
         memory: 128Mi
       limits:
         cpu: 200m
         memory: 256Mi
     ```

7. (Опционально) Настройте GitOps

   - Установите Argo CD:
     ```bash
     kubectl create namespace argocd
     kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
     ```
   - Создайте Application для синхронизации чарта из Git.

## Быстрый старт

Минимальные шаги для `minikube` + kube‑prometheus‑stack:

1. Запустите кластер: `minikube start`
1. Добавьте Helm-репозиторий: `helm repo add prometheus-community https://prometheus-community.github.io/helm-charts && helm repo update`
1. Установите monitoring stack: `helm install monitoring prometheus-community/kube-prometheus-stack -n monitoring --create-namespace`
1. Проверьте развёрнутые pod'ы: `kubectl get pods -n monitoring`
1. Добавьте в приложение endpoint `/metrics` с префиксом из варианта (счетчик запросов + гистограмма latency)
1. Создайте `ServiceMonitor` с label selector по приложению: `kubectl apply -f servicemonitor.yaml`
1. Пробросьте порт Grafana: `kubectl port-forward svc/monitoring-grafana 3000:80 -n monitoring`
1. Откройте Grafana (admin/prom-operator), создайте дашборд с панелями для ваших метрик
1. Убедитесь в наличии метрик в Prometheus: `kubectl port-forward svc/monitoring-kube-prometheus-prometheus 9090:9090 -n monitoring`
1. Создайте PrometheusRule с алертом по SLO: `kubectl apply -f prometheusrule.yaml`
1. Симулируйте нагрузку/ошибки и проверьте срабатывание алерта в Alertmanager
1. Упакуйте всё в Helm-чарт: `helm create my-app` и настройте templates
1. Установите чарт: `helm install my-app ./helm/my-app -n app-monitoring --create-namespace`

## Критерии приёмки

- Система мониторинга развёрнута (Prometheus, Grafana, Alertmanager доступны и функционируют).
- Метрики приложения корректно собираются через ServiceMonitor (демонстрация метрик в Prometheus).
- Созданы дашборды в Grafana (скриншоты или экспортированные JSON).
- Настроены алерты по SLO через PrometheusRule, продемонстрировано срабатывание хотя бы одного алерта.
- Helm-чарт приложения корректно деплоится (`helm install` без ошибок), включает все необходимые ресурсы.
- Манифесты содержат метаданные (labels/annotations). README содержит полное описание архитектуры мониторинга, шагов и скриншоты.

## Формат сдачи

- PR в основную ветку; назначить ревьювером `https://github.com/andreiNiasiuk`. В README: схема мониторинга, параметры варианта (prefix, SLO), шаги установки и проверки, скриншоты Grafana и Alertmanager, описание Helm-чарта, (опционально) настройка GitOps.

См. варианты в файле `Варианты.md`.

## Материалы для чтения

- kube‑prometheus‑stack: https://github.com/prometheus-operator/kube-prometheus
- Prometheus Docs: https://prometheus.io/docs/introduction/overview/
- Prometheus Client Libraries: https://prometheus.io/docs/instrumenting/clientlibs/
- PromQL Basics: https://prometheus.io/docs/prometheus/latest/querying/basics/
- Grafana: https://grafana.com/docs/
- ServiceMonitor: https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.ServiceMonitor
- PrometheusRule: https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.PrometheusRule
- Helm Charts: https://helm.sh/docs/
- OpenTelemetry: https://opentelemetry.io/
- Argo CD: https://argo-cd.readthedocs.io/
- Flux: https://fluxcd.io/

## Отладка и типичные ошибки

- Метрики не собираются: проверьте ServiceMonitor/PodMonitor и label selectors (`release: monitoring`), доступность endpoint `/metrics` через `curl`. Убедитесь, что Service имеет правильный selector и port name.
- Алерты не срабатывают: проверьте PrometheusRule через `kubectl get prometheusrule -A`, убедитесь что label `release: monitoring` присутствует. Проверьте статус алерта в Prometheus UI (`/alerts`).
- Helm‑релиз «битый»: выполните `helm lint ./chart`, проверьте валидность templates через `helm template`, убедитесь в отсутствии конфликта имен/namespace.
- GitOps не применяет изменения: проверьте доступ к Git-репозиторию, health‑статус Application в Argo CD UI, синхронизацию и события.
- Grafana не показывает метрики: проверьте datasource (Prometheus должен быть настроен автоматически), корректность PromQL запросов, временной диапазон.
