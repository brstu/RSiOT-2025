# Лабораторная работа 04. Наблюдаемость и метрики

Описание, цели, задания и критерии приёмки приведены ниже и в локальных методических материалах каталога `tasks/`.

## Описание

В этой работе студенты развёртывают систему мониторинга для Kubernetes-приложения: установка Prometheus и Grafana (kube-prometheus-stack), экспонирование метрик приложения, создание дашбордов и настройка алертов по SLO. Дополнительно рассматривается упаковка приложения в Helm-чарт и (опционально) внедрение GitOps с Argo CD/Flux. Документы и примеры находятся в каталоге `tasks/task_04/`.

## Цели

* Научиться устанавливать и настраивать систему мониторинга (Prometheus + Grafana) в Kubernetes.
* Добавить экспонирование метрик в приложение (endpoint `/metrics`) с использованием client-библиотек Prometheus.
* Создать ServiceMonitor/PodMonitor для автоматического сбора метрик.
* Разработать дашборды в Grafana для визуализации ключевых метрик (доступность, задержка, ошибки).
* Настроить алерты по SLO (Service Level Objectives) с использованием PrometheusRule и Alertmanager.
* Упаковать приложение в Helm-чарт с параметризацией основных настроек.
* (Опционально) Настроить GitOps-синхронизацию с использованием Argo CD или Flux.

## Материалы и варианты

* [Список вариантов](./Варианты.md).
* [Методические материалы](./Лабораторная_работа_04_Методические_материалы.md)

## Задания

1. Установить систему мониторинга:
    * Развернуть kube-prometheus-stack в namespace `monitoring` с помощью Helm;
    * Проверить доступность Prometheus, Grafana и Alertmanager;
    * Настроить доступ к Grafana (port-forward или Ingress).
2. Добавить метрики в приложение:
    * Интегрировать client-библиотеку Prometheus в приложение из ЛР01/ЛР02;
    * Создать endpoint `/metrics` с префиксом метрик согласно варианту;
    * Экспонировать базовые метрики: счётчик запросов, гистограмму задержек, gauge для статусов;
    * Создать ServiceMonitor или PodMonitor для автоматического обнаружения метрик.
3. Создать дашборды и алерты:
    * Разработать 2-3 дашборда в Grafana:
      - Доступность сервиса (availability);
      - Задержка p95/p99;
      - Частота ошибок 5xx.
    * Настроить 1-2 PrometheusRule с алертами по SLO из варианта (доступность, latency, error rate);
    * Проверить срабатывание алерта (симуляция нагрузки или ошибок).
4. Упаковать приложение в Helm-чарт:
    * Создать чарт с параметризацией: namespace, replicas, port, resources, ingressClass, метрики (prefix);
    * Templates: Deployment, Service, Ingress, ServiceMonitor, PrometheusRule;
    * Валидация: `helm lint`, `helm template`, успешная установка.
5. (Опционально) Настроить GitOps:
    * Установить Argo CD или Flux в кластер;
    * Создать Application/HelmRelease для автоматической синхронизации чарта из Git-репозитория;
    * Продемонстрировать автоматическое применение изменений при коммите.

## Артефакты (что сдаём)

* Helm-чарт приложения в каталоге `helm/` или `charts/` с параметризованными templates и values.yaml.
* Манифесты ServiceMonitor и PrometheusRule (могут быть включены в чарт).
* Экспортированные JSON дашборды Grafana или скриншоты дашбордов.
* Файл `README.md` с полным описанием:
  * Схема мониторинга и архитектура наблюдаемости;
  * Инструкции по установке kube-prometheus-stack;
  * Шаги деплоя приложения через Helm;
  * Описание метрик, дашбордов и алертов;
  * Скриншоты Grafana с метриками и алертами;
  * (Опционально) Настройка GitOps и демонстрация синхронизации.

---

### Метаданные (что указываем)

В README (корне проекта/папке) укажите:

* ФИО (полностью)
* Группа
* № студенческого (StudentID)
* Email (учебный)
* GitHub username
* Номер варианта
* Дата выполнения
* ОС (версия), версия Docker Desktop/Engine, версия kubectl, Helm, Minikube

В Kubernetes-манифестах/аннотациях/labels укажите следующее (пример для Deployment/Service):

* org.bstu.student.fullname = <ФИО>
* org.bstu.student.id = <StudentID>
* org.bstu.group = <Группа>
* org.bstu.variant = <Номер варианта>
* org.bstu.course = RSIOT

В metadata разделах Helm chart / k8s manifests можно добавить лейблы для owner/slug:

* org.bstu.owner = <GitHub username>
* org.bstu.student.slug = <slug>

slug = <группа>-<StudentID>-v<вариант> (пример, feis-41-12345-v07)

<!-- START:criteria -->
## Критерии оценивания (100 баллов)

* Установка и настройка kube-prometheus-stack (Prometheus, Grafana, Alertmanager) — 15
* Интеграция метрик в приложение (endpoint `/metrics`, правильный prefix, базовые метрики) — 20
* Настройка ServiceMonitor/PodMonitor для автоматического сбора метрик — 15
* Создание дашбордов в Grafana (2-3 дашборда: доступность, latency, ошибки) — 15
* Настройка алертов по SLO (PrometheusRule, демонстрация срабатывания) — 15
* Helm-чарт приложения с корректной параметризацией и templates — 15
* Метаданные, именование, оформление README и документация — 5

<!-- END:criteria -->

<!-- START:bonuses -->
## Бонусы (+ до 15)

* Настройка GitOps (Argo CD/Flux) с автоматической синхронизацией чарта из Git (+10).
* Реализация custom exporters или интеграция OpenTelemetry для трейсинга (+5).
* Настройка Alertmanager с роутингом алертов (email/Slack/webhook) (+5).
* Использование advanced PromQL запросов и recording rules для оптимизации (+3).

<!-- END:bonuses -->

### Требования к именованию

* Kubernetes-ресурсы: префиксы в именах: mon-<slug>, alert-<slug>, chart-<slug> — это облегчает поиск и очистку ресурсов.
* ENV: STU_ID, STU_GROUP, STU_VARIANT должны логироваться при старте контейнера.
* Namespace для приложения должен быть уникальным: app-<slug> или аналогичный.
* Helm release name: <slug>-app или уникальное имя по варианту.
